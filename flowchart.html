<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowchart Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f2f2f2;
            margin: 0;
            padding: 0;
        }
        .title-bar {
            background-color: #00265d; /* Penn State Blue */
            color: white;
            padding: 10px 0;
            text-align: center;
            font-size: 24px;
        }

        .created-by {
            font-size: 16px;
        }
        
        .login-container {
            width: 300px;
            margin: 100px auto;
            background-color: #fff;
            border: 2px solid #444;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        input[type="text"],
        input[type="password"],
        input[type="submit"] {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        input[type="submit"] {
            background-color: #4caf50;
            color: white;
            border: none;
            cursor: pointer;
        }
        input[type="submit"]:hover {
            background-color: #45a049;
        }
        #flowchartCanvas {
            border: 2px solid #444;
            display: block;
            margin: 20px auto;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        button {
            background-color: #4caf50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        textarea {
            display: block;
            margin: 20px auto;
            padding: 10px;
            width: 80%;
            max-width: 600px;
            height: 200px;
            resize: vertical;
        }
    </style>
</head>
<body>
    <div class="title-bar">
        <div>Flowchart Generator</div> <!-- Title Bar -->
        <div class="created-by">Created by Richard S. Lomax, Kirtan Patel, Talen Benes</div>
    </div>
    <div class="login-container">
        <h2>Login</h2>
        <form id="loginForm">
            <input type="text" id="username" placeholder="Username">
            <input type="password" id="password" placeholder="Password">
            <input type="submit" value="Login">
        </form>
    </div>

    <canvas id="flowchartCanvas" width="1500" height="1500"></canvas>
    <button id="showJsonButton">Show JSON</button>
    <button id="loadJsonButton">Load JSON</button>
    <textarea id="jsonInput" rows="10" cols="50" placeholder="Paste JSON data here"></textarea>

    <script>
        document.getElementById("loginForm").addEventListener("submit", function(event) {
            event.preventDefault();
            const username = document.getElementById("username").value;
            const password = document.getElementById("password").value;

            // Dummy authentication - Replace with your actual authentication logic
            if (username === "admin" && password === "password") {
                // Redirect to the flowchart page
                initializeFlowchart();
                document.getElementById("loginForm").reset(); // Reset the login form
                document.querySelector(".login-container").style.display = "none"; // Hide the login container
            } else {
                alert("Invalid username or password. Please try again.");
            }
        });

        function initializeFlowchart() {
            const canvas = document.getElementById("flowchartCanvas");
            const context = canvas.getContext("2d");

            const nodes = [];
            let selectedNode = null;
            let offsetX = 0;
            let offsetY = 0;

            canvas.addEventListener("mousedown", function (event) {
                const clickedNode = findNodeAtPosition(event.clientX, event.clientY);

                if (clickedNode) {
                    selectedNode = clickedNode;
                    offsetX = event.clientX - selectedNode.x;
                    offsetY = event.clientY - selectedNode.y;
                }
            });

            canvas.addEventListener("mousemove", function (event) {
                if (selectedNode) {
                    selectedNode.x = event.clientX - offsetX;
                    selectedNode.y = event.clientY - offsetY;
                    drawFlowchart();
                }
            });

            canvas.addEventListener("mouseup", function () {
                selectedNode = null;
            });

            canvas.addEventListener("click", function (event) {
                const newNode = {
                    x: event.clientX - canvas.getBoundingClientRect().left,
                    y: event.clientY - canvas.getBoundingClientRect().top,
                    width: 100,
                    height: 100, // Adjusted height for images
                    text: prompt("Enter text for the node:"),
                    shape: prompt("Choose shape (rectangle or ellipse):").toLowerCase(),
                    image: null,
                    connections: [],
                };

                // Ask user if they want to add an image
                const addImageDecision = confirm("Do you want to add an image to this node?");
                if (addImageDecision) {
                const imageUrl = prompt("Enter the URL of the image:");
                if (imageUrl) {
                    newNode.image = new Image();
                    newNode.image.onload = function() {
                        // Draw the image onto the canvas once it's fully loaded
                        context.drawImage(newNode.image, newNode.x + 15, newNode.y + 35, newNode.width - 30, newNode.height - 50);
                        drawFlowchart(); // Redraw the flowchart after the image is loaded
                    };
                    newNode.image.src = imageUrl;
                }
            }


                if (newNode.text || newNode.image) {
                    calculateNodeSize(newNode);
                    nodes.push(newNode);
                    drawFlowchart();

                    const connectDecision = confirm("Do you want to connect this node to another node?");
                    if (connectDecision) {
                        connectNodes(newNode);
                    }
                }
            });

            document.getElementById("showJsonButton").addEventListener("click", function () {
                alert(JSON.stringify(nodes, null, 2));
            });

            document.getElementById("loadJsonButton").addEventListener("click", function () {
                const jsonData = document.getElementById("jsonInput").value;
                try {
                    nodes.length = 0; // Clear existing nodes
                    const parsedNodes = JSON.parse(jsonData);
                    parsedNodes.forEach(node => {
                        // Convert image URLs to Image objects
                        if (node.image) {
                            node.image = new Image();
                            node.image.src = node.image;
                        }
                        nodes.push(node);
                    });
                    drawFlowchart();
                } catch (error) {
                    alert("Invalid JSON data. Please enter valid JSON.");
                }
            });

            function calculateNodeSize(node) {
                const textWidth = node.text ? context.measureText(node.text).width : 0;
                const textHeight = 18;
                const imageHeight = node.image ? node.height - textHeight : 0;
                node.width = Math.max(textWidth + 30, 100);
                node.height = Math.max(textHeight + 30 + imageHeight, 100);
            }

            function connectNodes(sourceNode) {
                const targetNodeIndex = prompt("Enter the index of the target node (starting from 0):");
                const targetNode = nodes[targetNodeIndex];

                if (targetNode) {
                    sourceNode.connections.push(targetNode);
                    drawFlowchart();
                }
            }

            function drawArrow(context, fromX, fromY, toX, toY) {
                const headLength = 10;

                context.beginPath();
                context.moveTo(fromX, fromY);
                context.lineTo(toX, toY);

                // Calculate arrowhead points
                const angle = Math.atan2(toY - fromY, toX - fromX);
                const arrowX1 = toX - headLength * Math.cos(angle - Math.PI / 6);
                const arrowY1 = toY - headLength * Math.sin(angle - Math.PI / 6);
                const arrowX2 = toX - headLength * Math.cos(angle + Math.PI / 6);
                const arrowY2 = toY - headLength * Math.sin(angle + Math.PI / 6);

                // Draw arrowhead
                context.moveTo(arrowX1, arrowY1);
                context.lineTo(toX, toY);
                context.lineTo(arrowX2, arrowY2);

                context.strokeStyle = "#000";
                context.lineWidth = 2;
                context.stroke();
                context.fillStyle = "#000";
                context.fill();
            }
            
function drawFlowchart() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    nodes.forEach(node => {
        context.beginPath();
        let textWidth = 0;
        if (node.text) {
            textWidth = context.measureText(node.text).width;
        }
        const textHeight = 18;
        const imageHeight = node.image ? node.height - textHeight : 0;

        // Calculate node size based on text width and height
        node.width = Math.max(textWidth + 30, 100);
        node.height = Math.max(textHeight + 30 + imageHeight, 100);

        // Draw node
        if (node.shape === "rectangle") {
            context.rect(node.x, node.y, node.width, node.height);
        } else if (node.shape === "ellipse") {
            context.ellipse(node.x + node.width / 2, node.y + node.height / 2, node.width / 2, node.height / 2, 0, 0, 2 * Math.PI);
        }
        context.fillStyle = "#000"; /* Pink */
        context.strokeStyle = "#d81b60"; /* Darker Pink */
        context.lineWidth = 3;
        context.stroke();
        context.fill();

        // Draw text
        context.fillStyle = "#fff"; /* White */
        context.font = "14px Arial";
        // Center the text within the node
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(node.text, node.x + node.width / 2, node.y + node.height / 2);

        // Draw image
        if (node.image) {
            context.drawImage(node.image, node.x + 15, node.y + 35, node.width - 30, node.height - 50);
        }
    });

    // Draw arrows and text
    nodes.forEach(node => {
        node.connections.forEach(targetNode => {
            const startX = node.x + node.width / 2;
            const startY = node.y + node.height;
            const endX = targetNode.x + targetNode.width / 2;
            const endY = targetNode.y;

            drawArrow(context, startX, startY, endX, endY);

            // Calculate text position
            const textX = (startX + endX) / 2;
            const textY = (startY + endY) / 2;

            // Draw text
            const text = prompt("Enter text for the line connecting these nodes:");
            context.fillStyle = "#000"; /* Black */
            context.font = "12px Arial";
            context.fillText(text, textX, textY);
        });
    });
}

function findNodeAtPosition(x, y) {
for (const node of nodes) {
if (
    (node.shape === "rectangle" && x >= node.x && x <= node.x + node.width && y >= node.y && y <= node.y + node.height) ||
    (node.shape === "ellipse" && Math.pow((x - (node.x + node.width / 2)) / (node.width / 2), 2) + Math.pow((y - (node.y + node.height / 2)) / (node.height / 2), 2) <= 1)
) {
    return node;
}
}
return null;
}

drawFlowchart();
};
</script>
</body>
</html>
